!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/2397d79/
Factoría	utils/Factoría.scala	/^object Factoría {$/;"	o
Main	Main.scala	/^object Main {$/;"	o
Partida	malla/Partida.scala	/^class Partida (dim_filas: Int, dim_cols: Int, niv: Int) {$/;"	c
Utils	utils/Utils.scala	/^object Utils {$/;"	o
ayuda	utils/Utils.scala	/^  val ayuda = "Uso: \\n" +$/;"	V
borrar	utils/Utils.scala	/^  def borrar (pos: Int, lista: List [Any]): List [Any] = {$/;"	m
buscar_lleno	Main.scala	/^  def buscar_lleno (lista: List [Any], idx: Int = 0): (Any, Int) = {$/;"	m
cambiado	Main.scala	/^        val cambiado: List [Any] = subir_diamante (columna, nivel)$/;"	V
cambiar	utils/Utils.scala	/^  def cambiar (lista: List [Any], pos_1: Int, pos_2: Int): List [Any] = {$/;"	m
cargar	Main.scala	/^  def cargar: (Partida, Int, List [Any]) = {$/;"	m
cargar_partida	utils/Utils.scala	/^  def cargar_partida (archivo: String): (Partida, Int, List [Any]) = {$/;"	m
col	Main.scala	/^    val col = Utils.pedir_opción (0, partida.columnas)$/;"	V
col	Main.scala	/^    val col = pieza._2$/;"	V
cols	Main.scala	/^    val cols = partida.columnas$/;"	V
cols	utils/Utils.scala	/^    val cols = partida.columnas$/;"	V
columnas	malla/Partida.scala	/^  val columnas: Int = dim_cols$/;"	V
columnas	utils/Utils.scala	/^      val columnas: Int = lista (1).filter (c => Character.isDigit (c)).toInt$/;"	V
combinar	Main.scala	/^  def combinar (horiz: List [Boolean], vert: List [Boolean]): List [Boolean] = {$/;"	m
comprobar_arg_nv	utils/Utils.scala	/^  private def comprobar_arg_nv (arg: String): Partida = {$/;"	m
comprobar_horiz	Main.scala	/^  def comprobar_horiz (partida: Partida, lista: List [Any]): List [Boolean] = {$/;"	m
comprobar_matriz	Main.scala	/^  def comprobar_matriz (partida: Partida, lista: List [Any]): List [Boolean] = {$/;"	m
comprobar_vert	Main.scala	/^  def comprobar_vert (partida: Partida, lista: List [Any]): List [Boolean] = {$/;"	m
contar_huecos	Main.scala	/^  def contar_huecos (lista: List [Any]): Int = {$/;"	m
contiene_elemento	Main.scala	/^  def contiene_elemento(elemento: Any,lista: List[Any]): Boolean = {$/;"	m
crear_diamante	utils/Utils.scala	/^  def crear_diamante (nivel: Int): Int = {$/;"	m
crear_lista	utils/Utils.scala	/^  def crear_lista (n: Int, nivel: Int): List [Int] = {$/;"	m
crear_partida	utils/Factoría.scala	/^  def crear_partida (niv: Int): Partida = {$/;"	m
datos	Main.scala	/^        val datos = cargar$/;"	V
datos	Main.scala	/^    val datos = Utils.cargar_partida (nombre)$/;"	V
datos	utils/Utils.scala	/^      val datos = scala.io.Source.fromFile (archivo)$/;"	V
diamante	malla/Partida.scala	/^  def diamante (valor: Int): String = {$/;"	m
elem	Main.scala	/^    val elem = columna.head$/;"	V
elem	Main.scala	/^    val elem = lista.head$/;"	V
elem_1	utils/Utils.scala	/^    val elem_1 = lista (pos_1)$/;"	V
elem_2	utils/Utils.scala	/^    val elem_2 = lista (pos_2)$/;"	V
eliminar	Main.scala	/^  def eliminar (lista: List [Any], marcadores: List [Boolean]): List [Any] = {$/;"	m
eliminar_coicidencias	Main.scala	/^  def eliminar_coicidencias (partida: Partida, estado: (Int,List[Any])): (Int, List [Any])= {$/;"	m
entrada	utils/Utils.scala	/^    val entrada = scala.io.StdIn.readLine ();$/;"	V
esNum	utils/Utils.scala	/^  def esNum (x: String) = !x.isEmpty && x.forall (Character.isDigit);$/;"	m
fila	Main.scala	/^    val fila = Utils.pedir_opción (0, partida.filas)$/;"	V
fila	Main.scala	/^    val fila = pieza._1$/;"	V
filas	malla/Partida.scala	/^  val filas: Int = dim_filas$/;"	V
filas	utils/Utils.scala	/^      val filas: Int = lista (0).filter (c => Character.isDigit (c)).toInt$/;"	V
guardar	Main.scala	/^  def guardar (partida: Partida, estado: (Int, List [Any])): Unit = {$/;"	m
horiz	Main.scala	/^    val horiz = comprobar_horiz (partida, lista)$/;"	V
huecos	Main.scala	/^        val huecos: List [Any] = eliminar (l, comprobar_matriz (partida, l))$/;"	V
if_else	utils/Utils.scala	/^  def if_else[T] (cond: Boolean, cod_if: () => T, cod_else: () => T = () => ()): T = {$/;"	m
imprimir_matriz	malla/Partida.scala	/^  def imprimir_matriz (lista: List [Any], cols: Int = columnas): Unit = {$/;"	m
insertar	utils/Utils.scala	/^  def insertar (color: Any, pos: Int, lista: List [Any]): List [Any] = {$/;"	m
insertar_col	utils/Utils.scala	/^  def insertar_col (partida: Partida$/;"	m
inv_aux	utils/Utils.scala	/^    def inv_aux (invertida: List [Any], lista: List [Any]) : List[Any] = {$/;"	m
invertir	utils/Utils.scala	/^  def invertir (lista: List [Any]): List [Any] = {$/;"	m
l	Main.scala	/^        val l: List [Any] = mover (pos$/;"	V
l	Main.scala	/^    val l = Utils.crear_lista (partida.filas * partida.columnas, partida.nivel)$/;"	V
lista	utils/Utils.scala	/^      val lista = try datos.getLines.toList finally datos.close ()$/;"	V
lista_col	Main.scala	/^        val lista_col = Utils.obtener_col (partida, lista, col)$/;"	V
lleno	Main.scala	/^    val lleno: (Any, Int) = buscar_lleno (columna)$/;"	V
log_error	utils/Utils.scala	/^  def log_error (msg: String): Unit = { print (" --> Error: " + msg + "\\n") }$/;"	m
long	Main.scala	/^    val long = lista.length$/;"	V
long	Main.scala	/^    val long = marcadores.length$/;"	V
long	Main.scala	/^    val long = vert.length$/;"	V
main	Main.scala	/^  def main (args: Array[String]) {$/;"	m
malla	malla/Partida.scala	/^package malla$/;"	p
mapear	utils/Utils.scala	/^  def mapear [A, B] (lista: List [A])(op: A => B): List [B] = {$/;"	m
mapear_indexado	utils/Utils.scala	/^  def mapear_indexado [A, B] (lista: List [A], contador: Int = 0)$/;"	m
matriz	Main.scala	/^        val matriz = Utils.insertar_col (partida, lista, col, salida)$/;"	V
matriz	Main.scala	/^    val matriz = eliminar (estado._2, comprobar_matriz (partida, estado._2))$/;"	V
matriz	utils/Utils.scala	/^      val matriz: List [Any] = mapear (lista (4).toList) {$/;"	V
matriz_enteros	utils/Utils.scala	/^      val matriz_enteros = mapear (matriz) {case e: Char => e.asDigit}$/;"	V
matriz_huecos	Main.scala	/^    val matriz_huecos: List [Any] = eliminar(matriz_mov, comprobar_matriz(partida,matriz_mov))$/;"	V
matriz_mov	Main.scala	/^    val matriz_mov = mover(elemento,partida,movimiento,estado)$/;"	V
matriz_sig	Main.scala	/^      val matriz_sig = tratar_huecos (partida, matriz)$/;"	V
menú	Main.scala	/^  def menú (partida: Partida, estado: (Int, List [Any])): Unit = {$/;"	m
misma_columna	utils/Utils.scala	/^  def misma_columna (A: Int, B: Int, C: Int, partida: Partida): Boolean = {$/;"	m
misma_fila	utils/Utils.scala	/^  def misma_fila (A: Int, B: Int, C: Int, partida: Partida): Boolean = {$/;"	m
mov	Main.scala	/^      val mov = pedir_mov(pos,partida)$/;"	V
mov_posible	Main.scala	/^  def mov_posible (pieza: (Int, Int), partida: Partida, movimiento: Int): Boolean = {$/;"	m
mov_valido	Main.scala	/^  def mov_valido(elemento: (Int, Int)$/;"	m
mover	Main.scala	/^  def mover (elemento: (Int, Int)$/;"	m
movimiento	Main.scala	/^    val movimiento: Int = Utils.pedir_opción (0, 3)$/;"	V
movimiento	Main.scala	/^  def movimiento (partida: Partida, estado: (Int, List [Any])): (Int, List [Any]) = {$/;"	m
msg_menú	Main.scala	/^  val msg_menú = "1) Realizar movimiento\\n" +$/;"	V
msg_mov	Main.scala	/^  val msg_mov  = "\\t0: Arriba\\n" +$/;"	V
nivel	malla/Partida.scala	/^  val nivel: Int = niv$/;"	V
nivel	utils/Utils.scala	/^      val nivel: Int = lista (2).filter (c => Character.isDigit (c)).toInt$/;"	V
nombre	Main.scala	/^    val nombre = scala.io.StdIn.readLine ()$/;"	V
nueva_matriz	Main.scala	/^        val nueva_matriz: List [Any] = tratar_huecos (partida, huecos)$/;"	V
nuevo_estado	Main.scala	/^    val nuevo_estado = eliminar_coicidencias (partida, estado)$/;"	V
obtener_args	utils/Utils.scala	/^  def obtener_args (args: Array [String]): Partida = {$/;"	m
obtener_col	utils/Utils.scala	/^  def obtener_col (partida: Partida, lista: List [Any], col: Int): List [Any] = {$/;"	m
p	utils/Utils.scala	/^    val p = new java.io.PrintWriter (archivo)$/;"	V
partida	Main.scala	/^    val partida: Partida = Utils.obtener_args (args)$/;"	V
pedir_mov	Main.scala	/^  def pedir_mov (pieza: (Int, Int), partida: Partida): Int = {$/;"	m
pedir_opción	utils/Utils.scala	/^  def pedir_opción (min: Int, max: Int): Int = {$/;"	m
pedir_pos	Main.scala	/^  def pedir_pos (partida: Partida): (Int, Int) = {$/;"	m
pos	Main.scala	/^      val pos: (Int, Int) = pedir_pos (partida)$/;"	V
puntos	Main.scala	/^        val puntos: Int = (estado._1 + contar_huecos (huecos))$/;"	V
puntos	Main.scala	/^      val puntos = estado._1 + contar_huecos (matriz)$/;"	V
puntos	utils/Utils.scala	/^      val puntos: Int = lista (3).filter (c => Character.isDigit (c)).toInt$/;"	V
res	utils/Utils.scala	/^      val res = op (lista.head)$/;"	V
res	utils/Utils.scala	/^      val res = op (lista.head, contador)$/;"	V
salida	Main.scala	/^        val salida =  Utils.invertir ($/;"	V
subir_diamante	Main.scala	/^  def subir_diamante (columna: List [Any], nivel: Int): List [Any] = {$/;"	m
toFile	utils/Utils.scala	/^  def toFile (archivo: java.io.File)(op: java.io.PrintWriter => Unit) {$/;"	m
toString	malla/Partida.scala	/^  def toString (estado: (Int, List [Any])): String = {$/;"	m
tratar_col	Main.scala	/^  def tratar_col (columna: List [Any], nivel: Int): List [Any] = {$/;"	m
tratar_huecos	Main.scala	/^  def tratar_huecos (partida: Partida, lista: List [Any]): List [Any] = {$/;"	m
tratar_huecos_aux_col	Main.scala	/^    def tratar_huecos_aux_col (partida: Partida$/;"	m
utils	utils/Factoría.scala	/^package utils$/;"	p
utils	utils/Utils.scala	/^package utils$/;"	p
vert	Main.scala	/^    val vert = comprobar_vert (partida, lista)$/;"	V
